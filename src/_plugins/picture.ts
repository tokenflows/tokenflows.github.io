// plugins/picture.ts
import { posix } from "./deps/path.ts";
import { typeByExtension } from "./deps/media_types.ts";
import type { MagickFormat } from "./deps/imagick.ts";
import type { Document, Element } from "./deps/dom.ts";
import type { Plugin, Site } from "lume/core.ts";

type Scale = Record<string, number>;
type ImgTransform = Map<string, Source>;

interface SourceFormat {
  width?: number;
  scales: Scale;
  format: string;
}

interface Source extends SourceFormat {
  paths: string[];
}

interface PathSegments {
  directory: string; 
  filename: string;
  extension: string;
} 

export interface Options {
  /** The key name for the transformations definitions */
  name: string;

  /** The priority order of the formats */
  order: string[];
  /** Treat all img elements as if they have the imagick attribute **/
  usedefault: boolean;
  /* THe default formats to use if not specified on the img element */
  formats: string;
  /* Light and dark color scheme names */
  colorschemes: string[]; 
}

// Default options
export const defaults: Options = {
  name: "imagick",
  order: ["jxl", "avif", "webp", "png", "jpg"],
  usedefault: false,
  formats: "webp png 800@2",
  colorschemes: ['light', 'dark'], 
};

export default function (userOptions?: Partial<Options>): Plugin {
  const options = merge(defaults, userOptions);
  
  return (site: Site) => {
    const transforms: ImgTransform = new Map<string, Source>();
    
    site.process([".html"], (page) => {
      const { document } = page;
      if (!document) { return; }
 
      const basePath = posix.dirname(page.outputPath!);
      const nodeList = document.querySelectorAll("img");
 
      // Enumerate the HTML to find all img elements. Identifying elements with the
      // 'imagick' attribute, then locating the nearest picture element so as to 
      // queue up the imagemagic image transformations. 
      for (const node of nodeList) {
        const img = node as Element;
        let imagick = img.closest("[imagick]")?.getAttribute("imagick");
        let ignorePicture = img.hasAttribute("ignorepicture");
        const useDefaultImagick = !imagick || ignorePicture;
        
        if (useDefaultImagick) {
          // Use page data over plugin defaults.
          const useDefault = page.data.imagick?.usedefault ?? options.usedefault;  

          if (ignorePicture ?? !useDefault ) { continue; }
          // QUESTION: Should this check for formats from the page data first before 
          //           defaulting to the options. 
          imagick = options.formats; 
        }

        if (!img.getAttribute("src")) {
          throw new Error("img element must have a src attribute");
        }

        if (!useDefaultImagick) {
          // Find the closet <picture> element in the html to handle the imagick image
          // transformations.
          const picture = img.closest("picture");
  
          if (picture) {
            handlePicture(imagick, img, picture, basePath, options.colorschemes);
            continue;
          }
        }
        // TODO: Check colorSchemes from the page data first, before defaulting to the 
        //       options. 
        handleImg(imagick, img, basePath, options.colorschemes);
      }        
    });

    // After completeting image transformations remove the imagick attribute from 
    // img elements that have it.
    site.process([".html"], (page) => {
      page.document?.querySelectorAll("[imagick]").forEach((element) => {
        (element as Element).removeAttribute("imagick");
      });
    });

    // Queue up all the image formats and sizes to be generated by imagemagick
    site.process("*", (page) => {
      const path = page.outputPath!;

      for (const { paths, width, scales, format } of transforms.values()) {
        if (!paths.includes(path)) {
          continue;
        }

        const { name } = options;
        const imagick = page.data[name] = page.data[name]
          ? Array.isArray(page.data[name]) ? page.data[name] : [page.data[name]]
          : [];

        for (const [suffix, scale] of Object.entries(scales)) {
          if (width) {
            imagick.push({resize: width * scale, suffix, format: format as MagickFormat});
            continue;
          }
          imagick.push({suffix, format: format as MagickFormat,});
        }
      }
    });

    // Locate img elements with the 'imagick' attribute and create the associated 
    // picture and source elements.
    function handlePicture(imagick: string, img: Element, picture: Element, basePath: string, colorSchemes: string[]) {
      const src = img.getAttribute("src") as string;
      const sizes = img.getAttribute("sizes");
      const sourceFormats = saveTransform(basePath, src, imagick, colorSchemes);

      sortSources(sourceFormats);
      const last = sourceFormats[sourceFormats.length - 1];

      for (const sourceFormat of sourceFormats) {
        if (sourceFormat === last) {
          editImg(img, src, last, sizes);
          break;
        }
        // enumerate over the colorSchemes even if there are no colorSchemes
        // specified. This ensures at least one source is created without altering
        // the image source.
        [...(colorSchemes || [null])].forEach(colorScheme => {
          const source = createSource(img.ownerDocument!, src, sourceFormat, colorScheme, sizes );
          // FIX: insertBefore comes from ./deps/dom.ts
          // picture.insertBefore(source, img); // <= FIX ME!
        });
      }
    }
    /*
       handleImg encapsulates the img element with a picture element and a sibling source
       element. Leaving the img element inplace to act as a fall-back for browsers that don't
       support the picture element. 
    */
    function handleImg(imagick: string, img: Element, basePath: string, colorSchemes: string[]) {
      const src = img.getAttribute("src") as string;
      const sizes = img.getAttribute("sizes");
      const sourceFormats = saveTransform(basePath, src, imagick, colorSchemes);
    
      sortSources(sourceFormats);

      // Just only one format, no need to create a picture element
      if (sourceFormats.length === 1) {
        editImg(img, src, sourceFormats[0], sizes);
        return;
      }

      const picture = img.ownerDocument!.createElement("picture");

      img.replaceWith(picture);

      const last = sourceFormats[sourceFormats.length - 1];

      for (const sourceFormat of sourceFormats) {
        if (sourceFormat === last) {
          editImg(img, src, last, sizes);
          break;
        }
        // enumerate over the colorSchemes even if there are no colorSchemes
        // specified. This ensures at least one source is created without altering
        // the image source.
        [...(colorSchemes || [null])].forEach(colorScheme => {
          const source = createSource(img.ownerDocument!, src, sourceFormat, colorScheme, sizes);
          picture.append(source);
        });          
      }

      picture.append(img);
    }
    /*
       sortSources
    */
    function sortSources(sources: SourceFormat[]) {
      const { order } = options;

      sources.sort((a, b) => {
        const aIndex = order.indexOf(a.format);
        const bIndex = order.indexOf(b.format);

        if (aIndex === -1) {
          return 1;
        }

        if (bIndex === -1) {
          return -1;
        }

        return aIndex - bIndex;
      });
    }
    /*
      Build the actual image source formats required and queue them up for imagic to create the 
      required formats. Enumerate over the image formats requested and add all the sizes requested.    
    */
    function saveTransform(basePath:string, src:string, imagick:string, colorSchemes: string[]):SourceFormat[] {
      // Construct the Source Formats. When no size has been specified assume the size is 1x.
      const constructOneSize = (format:string, _size:string):[string,SourceFormat] => {
        // Key to use for the format transform object and 1x size of the format requested.
        return [`:${format}`, {format, scales: { "" : 1 }}]; 
      }
      const constructManySizes = (format:string, size:string): [string, SourceFormat] => {
        const [width, requestedSizes] = parseSizes(size);
        const sourceFormat = {width, format, scales: {} as Scale};
        requestedSizes.forEach(scale => {
          const suffix = `-${width}w${scale === 1 ? "" : `@${scale}`}`;
          sourceFormat.scales[suffix] = scale;
        });
        return [`${width}:${format}`, sourceFormat]; 
      }
      const transformFormats = ( src: string, formats: string[], size: string, 
        cfs:(format:string,size:string) => [string,SourceFormat]): SourceFormat[] => {
        const sourceFormats: SourceFormat[] = [];
        formats.forEach(format => {
          const [key, expandedFormat] = cfs(format,size); 
          sourceFormats.push(expandedFormat);            
          // Get the format transform object.
          const transform = transforms.get(key);
          const ps = pathSegments(src);
          
          const themedSources = [...(colorSchemes||[null])].map( scheme => appendColorScheme(ps, scheme));
          // First time the format has been encounted so create the transform object.
          if (!transform) {
            transforms.set(key, {...expandedFormat, paths: themedSources });
          } else {
            themedSources.forEach( src => {
              if (!transform.paths.includes(src)) { transform.paths.push(src);}
              Object.assign(transform.scales, expandedFormat.scales);
            });
          }
        });
        
        return sourceFormats;  
      }
      // Parse the sizes requested in the imagick attribute string 
      const parseSizes = (size: string): [number, number[]] => {
        const match = size.match(/^(\d+)(@([\d.,]+))?$/); // match width@scale e.g. '800@2.5'
      
        if (!match) { throw new Error(`Invalid size: cannot match any 'width@scale' in '${size}'`); }
      
        const [, width, , scales] = match;
      
        // Use a Set to avoid duplicates
        const sizes = new Set<number>([1]);
        scales?.split(",").forEach((size) => sizes.add(parseFloat(size)));
      
        return [parseInt(width), [...sizes.values()]];
      }
      
      // Normalise and relative paths of the image source to an absolute path.
      const path = src.startsWith("/") ? src : posix.join(basePath, src);
      const sizes: string[] = []; // Sizes such as 200@3 880@2 etc.
      const formats: string[] = []; // Image types such as webp, png etc.
      // Separate sizes and formats from the imagick format string.
      imagick.trim().split(/\s+/).forEach((piece) => (piece.match(/^\d/)) ? sizes.push(piece): formats.push(piece));

      // Now build the sourceFormats and Transforms. 
      const sourceFormats: SourceFormat[] = !sizes.length? 
        transformFormats(path, formats, '', constructOneSize) : 
        sizes.map(size => transformFormats(path, formats, size, constructManySizes)).flat();

      return sourceFormats;
    }
  };
}

// BEGIN: From ./core/utils.ts 
function getPathAndExtension(path: string): [string, string] {
    const extension = getExtension(path);
    const pathWithoutExtension = path.slice(0, -extension.length);
    return [pathWithoutExtension, extension];
}

function getExtension(path: string): string {
  const match = path.match(/\.\w+$/);
  return match ? match[0] : "";
}

/** Helper to create optional properties recursively */
type DeepPartial<T> = T extends object ? {
  [P in keyof T]?: DeepPartial<T[P]>;
}
: T;

/**
 * Merge two objects recursively.
 * It's used to merge user options with default options.
 */
function merge<Type>(
  defaults: Type,
  user?: Partial<Type> | DeepPartial<Type>,
): Type {
  const merged = { ...defaults };

  if (!user) {
    return merged;
  }

  for (const [key, value] of Object.entries(user)) {
    if (value === undefined) {
      continue;
    }

    // @ts-ignore: No index signature with a parameter of type 'string' was found on type 'unknown'
    if (isPlainObject(merged[key]) && isPlainObject(value)) {
      // @ts-ignore: Type 'string' cannot be used to index type 'Type'
      merged[key] = merge(merged[key], value);
      continue;
    }

    // @ts-ignore: Type 'string' cannot be used to index type 'Type'
    merged[key] = value;
  }

  return merged;
}

// END:  From ./core/utils.ts 

/*
   Split the source path into directory, filename, and extension   
*/
function pathSegments(src: string): PathSegments {
  const parts = src.match(/^(.*\/)?(?:$|(.+?)(?:(\.[^.]*$)|$))/);
  if (!parts) { throw new Error('Invalid file path'); }
  return {directory:parts[1] || '', filename: parts[2] || '', extension:parts[3] || ''};
}

function appendColorScheme(path:PathSegments, scheme: string | null ): string {
  // no color scheme provided, just join the path segments. 
  const schemeSegment = scheme ? '-'+scheme : ''; 
  return `${path.directory}${path.filename}${schemeSegment}${path.extension}`;
}

/*
   Creates the set of sources for a particular image type. The source set
   includes any pixel desnity sizes such as '2x'.
*/
function createSrcset(
  src: string,
  srcFormat: SourceFormat,
  sizes?: string | null | undefined,
): string[] {
  const { scales, format, width } = srcFormat;
  const path = encodeURI(getPathAndExtension(src)[0]);
  const srcset: string[] = [];

  for (const [suffix, scale] of Object.entries(scales)) {
    const scaleSuffix = sizes && width
      ? ` ${scale * width}w`
      : scale === 1
      ? ""
      : ` ${scale}x`;
    srcset.push(`${path}${suffix}.${format}${scaleSuffix}`);
  }

  return srcset;
}

function createSource(
  document: Document,
  src: string,
  srcFormat: SourceFormat,
  colorScheme: string | null,
  sizes?: string | null | undefined,
) {
  const source = document.createElement("source");
  // A colour scheme name must have at least two characters.
  if (colorScheme) {
    src = appendColorScheme(pathSegments(src),colorScheme);
    source.setAttribute("media", `(prefers-color-scheme: ${colorScheme})`);
  }
  const srcset = createSrcset(src, srcFormat, sizes);

  source.setAttribute("srcset", srcset.join(", "));
  source.setAttribute("type", typeByExtension(srcFormat.format));

  if (sizes) {
    source.setAttribute("sizes", sizes);
  }

  return source;
}

function editImg(
  img: Element,
  src: string,
  srcFormat: SourceFormat,
  sizes?: string | null | undefined,
) {
  const srcset = createSrcset(src, srcFormat, sizes);
  const newSrc = srcset.shift()!;

  if (srcset.length) {
    img.setAttribute("srcset", srcset.join(", "));
  }
  img.setAttribute("src", newSrc);

  if (sizes) {
    img.setAttribute("sizes", sizes);
  }
}
